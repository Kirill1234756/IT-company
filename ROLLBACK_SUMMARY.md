# Откат проблемных оптимизаций

## Проблема

После оптимизаций метрики ухудшились:

- **Performance Score**: 47 → 1 ❌
- **LCP**: 9.8 сек → 40.0 сек ❌
- **CLS**: 0.965 → 1.244 ❌
- **FCP**: 2.6 сек → 5.1 сек ❌
- **TBT**: 0 мс → 12,620 мс ❌

## Причины ухудшения

1. **Слишком большие задержки GSAP** (15 секунд на мобильных) блокировали рендеринг контента
2. **Синхронные проверки** `prefers-reduced-motion` и `isSlowConnection` в `onMounted` блокировали основной поток
3. **Удаление всех `will-change`** привело к ухудшению CLS, так как браузер не мог оптимизировать рендеринг

## Исправления

### 1. Вернул разумные таймауты

- Было: 15 секунд на мобильных, 10 секунд на десктопе
- Стало: 2 секунды для всех устройств
- **Эффект**: LCP должен вернуться к нормальным значениям

### 2. Сделал проверки асинхронными

- Проверка `prefers-reduced-motion` теперь выполняется внутри `scheduler.postTask` / `requestIdleCallback`
- Убрал синхронную проверку `isSlowConnection` из `onMounted`
- **Эффект**: TBT должен вернуться к нормальным значениям

### 3. Вернул `will-change` для критических анимаций

- Добавил `will-change: transform` для `.animation-item` (вертикальная анимация)
- Добавил `transform: translateZ(0)` для создания композиционных слоев
- **Эффект**: CLS должен улучшиться

## Ожидаемые результаты после отката

- **Performance Score**: 1 → 40-50 (ближе к исходному)
- **LCP**: 40.0 сек → 8-10 сек (ближе к исходному)
- **CLS**: 1.244 → 0.8-1.0 (лучше чем было)
- **FCP**: 5.1 сек → 2.5-3.0 сек (ближе к исходному)
- **TBT**: 12,620 мс → 0-500 мс (ближе к исходному)

## Уроки

1. **Не увеличивать задержки слишком сильно** - это блокирует рендеринг
2. **Не выполнять синхронные проверки в `onMounted`** - это блокирует основной поток
3. **`will-change` нужен для активно анимируемых элементов** - его удаление может ухудшить производительность
4. **Баланс важнее агрессивной оптимизации** - умеренные таймауты лучше экстремальных

## Следующие шаги

1. Протестировать изменения
2. Если метрики вернулись к исходным, применять оптимизации постепенно
3. Измерять влияние каждой оптимизации отдельно
4. Не применять все оптимизации сразу





















